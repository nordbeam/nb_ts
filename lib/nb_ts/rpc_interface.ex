defmodule NbTs.RpcInterface do
  @moduledoc """
  Generates TypeScript types for NbRpc procedure modules.

  Produces:
  1. Input/output interfaces for each procedure
  2. A scope type per procedure module
  3. The `AppRouter` type that combines all scopes

  The generated `AppRouter` type is consumed by `@nordbeam/nb-rpc/client`
  and `@nordbeam/nb-rpc/react` to provide end-to-end type safety.
  """

  alias NbTs.TypeMapper

  @primitive_types [:string, :integer, :float, :number, :boolean, :map, :any,
                    :date, :datetime, :decimal, :uuid]

  @doc """
  Generate the full AppRouter TypeScript file content.

  Discovers all scopes and procedure modules, then generates a single
  file containing all input/output types and the router type.
  """
  @spec generate_router_type() :: {String.t(), String.t()}
  def generate_router_type do
    scopes = NbTs.RpcDiscovery.discover_scopes()

    if scopes == [] do
      {"AppRouter", ""}
    else
      typescript = generate_typescript(scopes)
      {"AppRouter", typescript}
    end
  end

  @doc """
  Generate TypeScript for the router and all procedure types.
  """
  @spec generate_typescript([{String.t(), module()}]) :: String.t()
  def generate_typescript(scopes) do
    # Collect all serializer imports needed
    {scope_types, all_imports} =
      Enum.map_reduce(scopes, MapSet.new(), fn {prefix, module}, imports ->
        {scope_ts, scope_imports} = generate_scope_type(prefix, module)
        {scope_ts, MapSet.union(imports, scope_imports)}
      end)

    # Build import statements
    import_lines = generate_imports(all_imports)

    # Build nb-rpc type imports
    rpc_import = ~s(import type { QueryDef, MutationDef, SubscriptionDef } from "@nordbeam/nb-rpc/types";\n)

    # Build the AppRouter type
    scope_entries =
      scopes
      |> Enum.map(fn {prefix, _module} ->
        type_name = scope_type_name(prefix)
        "  #{camelize(prefix)}: #{type_name};"
      end)
      |> Enum.join("\n")

    router_type = """
    export type AppRouter = {
    #{scope_entries}
    };
    """

    # Combine everything
    parts = [
      "// Auto-generated by nb_ts — do not edit manually",
      "",
      rpc_import,
      import_lines,
      "",
      Enum.join(scope_types, "\n\n"),
      "",
      router_type
    ]

    parts
    |> Enum.reject(&(&1 == ""))
    |> Enum.join("\n")
  end

  # -- Scope type generation --

  defp generate_scope_type(prefix, module) do
    procedures = module.__nb_rpc_procedures__()
    type_name = scope_type_name(prefix)

    {procedure_entries, imports} =
      Enum.map_reduce(procedures, MapSet.new(), fn {name, def}, imports ->
        {entry, proc_imports} = generate_procedure_entry(name, def)
        {entry, MapSet.union(imports, proc_imports)}
      end)

    entries_str = Enum.join(procedure_entries, "\n")

    typescript = """
    export type #{type_name} = {
    #{entries_str}
    };
    """

    {typescript, imports}
  end

  defp generate_procedure_entry(name, %{type: type, input: input_spec, output: output_spec}) do
    {input_type, input_imports} = spec_to_typescript(input_spec, :input)
    {output_type, output_imports} = spec_to_typescript(output_spec, :output)

    type_wrapper = case type do
      :query -> "QueryDef"
      :mutation -> "MutationDef"
      :subscription -> "SubscriptionDef"
    end

    entry = "  #{camelize(to_string(name))}: #{type_wrapper}<#{input_type}, #{output_type}>;"
    imports = MapSet.union(input_imports, output_imports)

    {entry, imports}
  end

  # -- Type spec to TypeScript conversion --

  # nil spec → empty object / unknown
  defp spec_to_typescript(nil, :input), do: {"Record<string, never>", MapSet.new()}
  defp spec_to_typescript(nil, :output), do: {"unknown", MapSet.new()}

  # Zoi schema
  defp spec_to_typescript(%{__struct__: struct} = schema, direction) when is_atom(struct) do
    if zoi_schema?(struct) do
      zoi_to_typescript(schema, direction)
    else
      # Treat as regular map (strip struct key)
      spec_to_typescript(Map.from_struct(schema), direction)
    end
  end

  # Inline map spec
  defp spec_to_typescript(spec, _direction) when is_map(spec) do
    {fields, imports} =
      Enum.map_reduce(spec, MapSet.new(), fn {field, type_spec}, imports ->
        {ts_type, optional, field_imports} = field_spec_to_typescript(type_spec)
        opt = if optional, do: "?", else: ""
        field_str = "  #{camelize(to_string(field))}#{opt}: #{ts_type};"
        {field_str, MapSet.union(imports, field_imports)}
      end)

    type_str = "{\n  #{Enum.join(fields, "\n  ")}\n  }"
    {type_str, imports}
  end

  # Module spec (serializer)
  defp spec_to_typescript(module, _direction) when is_atom(module) do
    if serializer_module?(module) do
      name = interface_name(module)
      {name, MapSet.new([module])}
    else
      type_info = %{type: module}
      {TypeMapper.to_typescript(type_info), MapSet.new()}
    end
  end

  # Catch-all
  defp spec_to_typescript(_spec, _direction), do: {"unknown", MapSet.new()}

  # -- Field spec parsing --

  defp field_spec_to_typescript(type) when type in @primitive_types do
    ts = TypeMapper.to_typescript(%{type: type})
    {ts, false, MapSet.new()}
  end

  # {:type, opts} like {:string, optional: true}
  defp field_spec_to_typescript({type, opts}) when type in @primitive_types and is_list(opts) do
    ts = TypeMapper.to_typescript(%{type: type})
    optional = Keyword.get(opts, :optional, false)
    nullable = Keyword.get(opts, :nullable, false)
    default = Keyword.has_key?(opts, :default)

    ts = if nullable, do: "#{ts} | null", else: ts
    {ts, optional || default, MapSet.new()}
  end

  # {:enum, ["a", "b"]}
  defp field_spec_to_typescript({:enum, values}) when is_list(values) do
    ts = values |> Enum.map(&inspect/1) |> Enum.join(" | ")
    {ts, false, MapSet.new()}
  end

  # {:list, :string} or {:list, SomeSerializer}
  defp field_spec_to_typescript({:list, element_type}) when element_type in @primitive_types do
    inner = TypeMapper.to_typescript(%{type: element_type})
    {"Array<#{inner}>", false, MapSet.new()}
  end

  defp field_spec_to_typescript({:list, module}) when is_atom(module) do
    if serializer_module?(module) do
      name = interface_name(module)
      {"Array<#{name}>", false, MapSet.new([module])}
    else
      {"Array<unknown>", false, MapSet.new()}
    end
  end

  # Serializer module as type
  defp field_spec_to_typescript(module) when is_atom(module) do
    if serializer_module?(module) do
      name = interface_name(module)
      {name, false, MapSet.new([module])}
    else
      ts = TypeMapper.to_typescript(%{type: module})
      {ts, false, MapSet.new()}
    end
  end

  # Nested map
  defp field_spec_to_typescript(spec) when is_map(spec) do
    {ts, imports} = spec_to_typescript(spec, :input)
    {ts, false, imports}
  end

  # Catch-all
  defp field_spec_to_typescript(_), do: {"unknown", false, MapSet.new()}

  # -- Import generation --

  defp generate_imports(import_set) do
    import_set
    |> MapSet.to_list()
    |> Enum.filter(&serializer_module?/1)
    |> Enum.map(fn module ->
      name = interface_name(module)
      filename = serializer_filename(module)
      ~s(import type { #{name} } from "./#{filename}";)
    end)
    |> Enum.sort()
    |> Enum.join("\n")
  end

  # -- Zoi schema → TypeScript (via JSON Schema) --

  defp zoi_schema?(struct) do
    Code.ensure_loaded?(Zoi) and
      String.starts_with?(Atom.to_string(struct), "Elixir.Zoi.Types.")
  end

  defp zoi_to_typescript(schema, direction) do
    try do
      json_schema = apply(Zoi, :to_json_schema, [schema])
      {json_schema_to_typescript(json_schema), MapSet.new()}
    rescue
      _ ->
        case direction do
          :input -> {"Record<string, never>", MapSet.new()}
          :output -> {"unknown", MapSet.new()}
        end
    end
  end

  # enum must match before primitives — Zoi emits both `type` and `enum` keys
  defp json_schema_to_typescript(%{enum: values}) do
    values |> Enum.map(&json_schema_literal/1) |> Enum.join(" | ")
  end

  defp json_schema_to_typescript(%{const: value}) when is_binary(value), do: inspect(value)
  defp json_schema_to_typescript(%{const: value}) when is_number(value) or is_boolean(value), do: to_string(value)

  defp json_schema_to_typescript(%{type: :string}), do: "string"
  defp json_schema_to_typescript(%{type: :integer}), do: "number"
  defp json_schema_to_typescript(%{type: :number}), do: "number"
  defp json_schema_to_typescript(%{type: :boolean}), do: "boolean"
  defp json_schema_to_typescript(%{type: :null}), do: "null"

  defp json_schema_to_typescript(%{type: :array, items: items}) do
    "Array<#{json_schema_to_typescript(items)}>"
  end

  defp json_schema_to_typescript(%{type: :array, prefixItems: items}) do
    # Tuple type
    inner = items |> Enum.map(&json_schema_to_typescript/1) |> Enum.join(", ")
    "[#{inner}]"
  end

  defp json_schema_to_typescript(%{type: :object, properties: props} = schema) do
    required = Map.get(schema, :required, [])

    fields =
      Enum.map(props, fn {field, field_schema} ->
        ts_type = json_schema_to_typescript(field_schema)
        opt = if field in required, do: "", else: "?"
        "  #{camelize(to_string(field))}#{opt}: #{ts_type};"
      end)

    "{\n  #{Enum.join(fields, "\n  ")}\n  }"
  end

  defp json_schema_to_typescript(%{anyOf: schemas}) do
    schemas |> Enum.map(&json_schema_to_typescript/1) |> Enum.join(" | ")
  end

  defp json_schema_to_typescript(%{allOf: schemas}) do
    schemas |> Enum.map(&json_schema_to_typescript/1) |> Enum.join(" & ")
  end

  defp json_schema_to_typescript(%{oneOf: schemas}) do
    schemas |> Enum.map(&json_schema_to_typescript/1) |> Enum.join(" | ")
  end

  defp json_schema_to_typescript(_), do: "unknown"

  defp json_schema_literal(value) when is_binary(value), do: inspect(value)
  defp json_schema_literal(value) when is_number(value), do: to_string(value)
  defp json_schema_literal(value) when is_boolean(value), do: to_string(value)
  defp json_schema_literal(nil), do: "null"
  defp json_schema_literal(value) when is_atom(value), do: inspect(to_string(value))
  defp json_schema_literal(_), do: "unknown"

  # -- Helpers --

  defp scope_type_name(prefix) do
    prefix
    |> String.split(".")
    |> Enum.map(&String.capitalize/1)
    |> Enum.join("")
    |> Kernel.<>("Scope")
  end

  defp camelize(string) do
    [first | rest] = String.split(string, "_")
    first <> Enum.map_join(rest, &String.capitalize/1)
  end

  defp interface_name(module) do
    module
    |> Module.split()
    |> List.last()
    |> String.replace(~r/Serializer$/, "")
  end

  defp serializer_filename(module) do
    base = module |> Module.split() |> List.last()

    if function_exported?(module, :__nb_serializer_typescript_namespace__, 0) do
      case module.__nb_serializer_typescript_namespace__() do
        nil -> base
        namespace when is_binary(namespace) -> "#{namespace}#{base}"
      end
    else
      base
    end
  end

  defp serializer_module?(module) when is_atom(module) do
    Code.ensure_loaded?(module) and
      function_exported?(module, :__nb_serializer_type_metadata__, 0)
  end
end
